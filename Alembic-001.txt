// File: lib/core/arcane_repository.dart
import 'dart:io';

import 'package:alembic/main.dart';
import 'package:alembic/screen/home.dart';
import 'package:alembic/screen/settings.dart';
import 'package:alembic/widget/repository_tile.dart';
import 'package:arcane/arcane.dart';
import 'package:fast_log/fast_log.dart';
import 'package:github/github.dart';

enum RepoState { active, archived, cloud }

BehaviorSubject<List<(Repository, String)>> repoWork =
    BehaviorSubject.seeded([]);

class ArcaneRepository {
  final Repository repository;
  bool? _specific;

  ArcaneRepository({required this.repository});

  bool shouldBeSpecific() {
    _specific ??= active.where((i) => i.name == repository.name).length > 1;
    return _specific!;
  }

  Future<T> doWork<T>(String msg, Future<T> Function() work) async {
    (Repository, String) job = (repository, msg);
    repoWork.add([...repoWork.value, job]);
    T t = await work();
    repoWork.add([
      ...repoWork.value.where((i) => i != job),
    ]);

    return t;
  }

  Stream<List<String>> streamWork() => repoWork.stream
      .map((i) => i.where((i) => i.$1 == repository).map((i) => i.$2).toList());

  String get repoPath => expandPath(
      "${config.workspaceDirectory}/${repository.owner?.login}/${repository.name}");

  String get imagePath => expandPath(
      "${config.archiveDirectory}/archives/${repository.owner?.login ?? 'unknown'}/${repository.name}.zip");

  String get authenticatedCloneUrl =>
      "https://${box.get("1")}:x-oauth-basic@github.com/${repository.owner?.login}/${repository.name}.git";

  Future<bool> get isStaleActive async {
    if (!await isActive) return false;
    int? lastOpen = getRepoConfig(repository).lastOpen;
    if (lastOpen == null) return false;

    if (DateTime.timestamp().millisecondsSinceEpoch - lastOpen >
        Duration(days: config.daysToArchive).inMilliseconds) {
      return true;
    }

    return false;
  }

  Future<void> archiveFromCloud(GitHub github) => doWork("Archiving", () async {
        if (await isArchived) return;
        if (await isActive) return;
        await ensureRepositoryActive(github, updateActive: false);
        await archive();
      });

  Future<void> archive() => doWork("Archiving", () async {
        if (await isArchived) return;
        if (!await isActive) return;
        File(imagePath).absolute.parent.createSync(recursive: true);
        int exitCode = await cmd('zip', ['-r', imagePath, '.'],
            workingDirectory: repoPath);
        // We run zip with workingDirectory = repoPath so that it zips the current directory ('.')

        if (exitCode != 0) {
          throw Exception('Failed to create zip archive at $imagePath');
        }

        success("Archived repository at $repoPath to $imagePath");
        await deleteRepository();
        active.remove(repository);
        update.add(update.value + 1);
      });

  Future<void> unarchive(GitHub github,
          {bool waitForPull = false, bool notifyActive = true}) =>
      doWork("Extracting", () async {
        if (!await isArchived) return;
        if (await isActive) return;
        await Directory(repoPath).create(recursive: true);
        int exitCode = await cmd('unzip', [imagePath, '-d', repoPath]);

        if (exitCode != 0) {
          throw Exception('Failed to unzip archive at $imagePath');
        }

        await File(imagePath).delete();

        success("Unarchived repository to $repoPath from $imagePath");

        if (notifyActive) {
          active.add(repository);
          update.add(update.value + 1);
        }
        setRepoConfig(
            repository,
            getRepoConfig(repository)
              ..lastOpen = DateTime.timestamp().millisecondsSinceEpoch);
        Future<void> pull = ensureRepositoryUpdated(github);

        if (waitForPull) {
          await pull;
        }
      });

  Future<void> deleteRepository() => doWork("Deleting", () async {
        int exitCode = await cmd('rm', ['-rf', repoPath]);

        if (exitCode != 0) {
          throw Exception('Failed to delete repository at $repoPath');
        }

        info("Deleted repository at $repoPath");
        active.remove(repository);
        update.add(update.value + 1);
      });

  Future<void> deleteArchive() => doWork("Deleting Archive", () async {
        if (!await isArchived) return;
        await File(imagePath).delete();
        info("Deleted archive at $repoPath");
      });

  Future<void> updateArchive(GitHub github) => doWork("Updating", () async {
        if (!await isArchived) return;
        await unarchive(github, waitForPull: true, notifyActive: false);
        await archive();
      });

  Future<int> get sizeKB async {
    BehaviorSubject<String> stdout = BehaviorSubject();
    int? kb;
    stdout.listen((e) => kb ??= int.tryParse(e.split("\t").first));
    await cmd('du', ['-sk', repoPath], stdout: stdout);
    return kb ?? -1;
  }

  Future<bool> get isArchived => File(imagePath).exists();
  bool get isArchivedSync => File(imagePath).existsSync();

  Future<RepoState> get state =>
      Future.wait([isActive, isArchived]).then((v) => v[0]
          ? RepoState.active
          : v[1]
              ? RepoState.archived
              : RepoState.cloud);

  Future<void> runAutoMacros() async {
    for (String path in [
      ...await findDartPackages(
              "$repoPath/${getRepoConfig(repository).openDirectory}"
                  .replaceAll("//", "/"))
          .toList(),
      ...await findDartPackages(repoPath).toList()
    ]) {
      warn("IN $path");
      cmd("flutter", ["pub", "get"], workingDirectory: path);
    }
  }

  Stream<String> findDartPackages(String path) async* {
    if (await File("$path/pubspec.yaml").exists()) {
      yield path;
    }

    for (FileSystemEntity entity
        in Directory(path).listSync(followLinks: false)) {
      if (entity is Directory) {
        if (entity.path.endsWith(".plugin_symlinks")) continue;

        yield* findDartPackages(entity.path);
      }
    }
  }

  Future<void> openInFinder() async =>
      cmd('open', [Directory(repoPath).absolute.path]);

  Future<void> open(GitHub github, BuildContext context) =>
      doWork("Opening", () async {
        await ensureRepositoryActive(github);
        ApplicationTool tool =
            getRepoConfig(repository).editorTool ?? config.editorTool;
        info("Opening ${repository.fullName} with IDE ${tool.displayName}");
        ensureRepositoryUpdated(github);
        tool.launch("$repoPath/${getRepoConfig(repository).openDirectory}"
            .replaceAll("//", "/"));
        GitTool gitTool = getRepoConfig(repository).gitTool ?? config.gitTool;
        info(
            "Opening ${repository.fullName} with Git Client ${gitTool.displayName}");
        gitTool.launch(repoPath);
        runAutoMacros();
        setRepoConfig(
            repository,
            getRepoConfig(repository)
              ..lastOpen = DateTime.timestamp().millisecondsSinceEpoch);
      });

  Future<bool> get isActive => Directory("$repoPath/.git").exists();
  bool get isActiveSync => Directory("$repoPath/.git").existsSync();

  Future<void> ensureRepositoryActive(GitHub github,
          {bool updateActive = true}) =>
      doWork("Activating", () async {
        Directory repoDir = Directory(repoPath);

        if (!await repoDir.exists()) {
          if (await isArchived) {
            await unarchive(github, waitForPull: false, notifyActive: true);
          } else {
            await doWork("Cloning", () async {
              syncingRepositories.add({
                ...syncingRepositories.value,
                repository,
              }.toList());
              await repoDir.create(recursive: true);
              String cloneUrl = authenticatedCloneUrl;
              info("Cloning ${repository.fullName} from $cloneUrl");
              if (await cmd('git', ['clone', cloneUrl, repoPath]) != 0) {
                syncingRepositories.add(syncingRepositories.value
                    .where((i) => i.fullName != repository.fullName)
                    .toList());
                throw Exception('Git clone failed!');
              }
              syncingRepositories.add(syncingRepositories.value
                  .where((i) => i.fullName != repository.fullName)
                  .toList());
              success("Cloned ${repository.fullName}");
              if (updateActive) {
                active.add(repository);
              }
              setRepoConfig(
                  repository,
                  getRepoConfig(repository)
                    ..lastOpen = DateTime.timestamp().millisecondsSinceEpoch);
            });
          }
        } else {
          info("Repository ${repository.fullName} already exists $repoPath");
        }
        update.add(update.value + 1);
      });

  Future<void> ensureRepositoryUpdated(GitHub github) =>
      doWork("Pulling", () async {
        info("Pulling ${repository.fullName} ");
        if (await cmd('git', ['-C', repoPath, 'pull']) != 0) {
          throw Exception('Git pull failed!');
        }

        success("Pulled ${repository.fullName}");
        update.add(update.value + 1);
      });
}
// File: lib/widget/organization_section.dart
import 'package:alembic/util/extensions.dart';
import 'package:alembic/widget/link_menu.dart';
import 'package:alembic/widget/repository_list.dart';
import 'package:arcane/arcane.dart';
import 'package:github/github.dart';

class OrganizationSection extends StatelessWidget {
  OrganizationSection({super.key});

  @override
  Widget build(BuildContext context) =>
      context.search.buildNullable((query) => Pylon<List<Repository>>(
            key: ValueKey("org.${context.organization.login}.${query ?? ""}"),
            value: context.organizations[context.organization]!.filterBy(query),
            builder: (context) => context.repositories.isEmpty
                ? const SliverToBoxAdapter()
                : BarSection(
                    trailing: [
                        IconButtonMenu(icon: Icons.dots_three_vertical, items: [
                          linkMenu(
                              text: "New Repository",
                              url:
                                  "https://github.com/organizations/${context.organization.login}/repositories/new",
                              icon: Icons.plus)
                        ])
                      ],
                    headerText: context.organization.login,
                    sliver: RepositoryListView()),
          ));
}
// File: lib/widget/personal_section.dart
import 'package:alembic/util/extensions.dart';
import 'package:alembic/widget/link_menu.dart';
import 'package:alembic/widget/repository_list.dart';
import 'package:arcane/arcane.dart';

class PersonalSection extends StatelessWidget {
  PersonalSection({super.key});

  @override
  Widget build(BuildContext context) => context.repositories.isEmpty
      ? const SliverToBoxAdapter()
      : BarSection(
          headerText: "Personal",
          sliver: RepositoryListView(),
          trailing: [
              IconButtonMenu(icon: Icons.dots_three_vertical, items: [
                linkMenu(
                    text: "New Repository",
                    url: "https://github.com/new",
                    icon: Icons.plus)
              ])
            ]);
}

// https://github.com/organizations/ArcaneArts/repositories/new
// File: lib/widget/link_menu.dart
import 'package:arcane/arcane.dart';
import 'package:url_launcher/url_launcher_string.dart';

MenuItem linkMenu({
  required String text,
  required String url,
  required IconData icon,
  List<MenuItem>? subMenu,
}) =>
    MenuButton(
        leading: Icon(icon),
        subMenu: subMenu,
        onPressed: () => launchUrlString(url),
        child: Text(text));
// File: lib/widget/repository_tile.dart
import 'package:alembic/core/arcane_repository.dart';
import 'package:alembic/screen/home.dart';
import 'package:alembic/screen/repository_settings.dart';
import 'package:alembic/util/extensions.dart';
import 'package:alembic/util/window.dart';
import 'package:alembic/widget/link_menu.dart';
import 'package:arcane/arcane.dart';
import 'package:github/github.dart';

BehaviorSubject<List<Repository>> syncingRepositories =
    BehaviorSubject.seeded([]);

class RepositoryTile extends StatefulWidget {
  RepositoryTile({super.key});

  @override
  State<RepositoryTile> createState() => _RepositoryTileState();
}

class _RepositoryTileState extends State<RepositoryTile>
    with AutomaticKeepAliveClientMixin {
  @override
  Widget build(BuildContext context) {
    super.build(context);

    return Pylon<ArcaneRepository>(
      value: ArcaneRepository(repository: context.repository),
      builder: (context) => context.arepository.state.build((state) =>
          ContextMenu(
              items: buildMenu(context, state),
              child: syncingRepositories
                  .map((i) =>
                      i.any((g) => g.fullName == context.repository.fullName))
                  .distinct()
                  .build((loading) => context.arepository
                      .streamWork()
                      .buildNullable(
                        (work) => ListTile(
                            subtitle: work?.isNotEmpty ?? false
                                ? Row(
                                    mainAxisSize: MainAxisSize.min,
                                    children: [
                                      const CircularProgressIndicator(),
                                      const Gap(4),
                                      Text(work!.join(", ")).xSmall(),
                                    ],
                                  )
                                : context.arepository.shouldBeSpecific()
                                    ? Text(context.repository.owner?.login ??
                                            "?")
                                        .xSmall()
                                    : null,
                            trailing: loading
                                ? const CircularProgressIndicator()
                                : context.arepository.state.build(
                                    (state) => switch (state) {
                                          RepoState.active => Clickable(
                                              child:
                                                  const Icon(Icons.folder_fill),
                                              onPressed: () => open(context),
                                            ),
                                          RepoState.cloud =>
                                            const Icon(Icons.cloud),
                                          RepoState.archived =>
                                            const Icon(Icons.archive),
                                        },
                                    loading: const CircularProgressIndicator()),
                            onPressed: () => context.arepository
                                .open(context.github, context),
                            title: Text(context.repository.name)),
                      )))),
    );
  }

  void open(BuildContext context) {
    WindowUtil.hide();
    context.arepository.openInFinder().then((i) {
      update.add(update.value + 1);
    });
  }

  List<MenuItem> buildMenu(BuildContext context, RepoState state) => [
        MenuButton(
          onPressed: () => open(context),
          leading: const Icon(Icons.pencil),
          child: const Text("Open"),
        ),
        MenuButton(
          leading: const Icon(Icons.gear_six),
          onPressed: () => Arcane.push(context, const RepositorySettings()),
          child: const Text("Configure"),
        ),
        const MenuDivider(),
        linkMenu(
            text: "View on Github",
            url:
                "https://github.com/${context.repository.owner?.login}/${context.repository.name}",
            icon: Icons.open_ionic),
        linkMenu(
            text: "Issues",
            url:
                "https://github.com/${context.repository.owner?.login}/${context.repository.name}/issues",
            icon: Icons.open_ionic),
        linkMenu(
            text: "Pull Requests",
            url:
                "https://github.com/${context.repository.owner?.login}/${context.repository.name}/pulls",
            icon: Icons.open_ionic),
        const MenuDivider(),
        linkMenu(
            text: "New Issue",
            url:
                "https://github.com/${context.repository.owner?.login}/${context.repository.name}/issues/new",
            icon: Icons.plus),
        linkMenu(
            text: "New Pull Request",
            url:
                "https://github.com/${context.repository.owner?.login}/${context.repository.name}/compare",
            icon: Icons.plus),
        const MenuDivider(),
        if (state == RepoState.active) ...[
          MenuButton(
              leading: const Icon(Icons.download),
              child: const Text("Pull"),
              onPressed: () =>
                  context.arepository.ensureRepositoryUpdated(context.github)),
          MenuButton(
              leading: const Icon(Icons.archive),
              onPressed: () => context.arepository.archive(),
              child: const Text("Archive")),
          MenuButton(
              leading: const Icon(Icons.trash),
              onPressed: () => DialogConfirm(
                  title: "Delete ${context.repository.fullName}?",
                  destructive: true,
                  confirmText: "Delete Project",
                  description:
                      "Are you sure you want to delete this repository from your active workspace? THERE COULD BE UNSTAGED OR UNPUSHED LOCAL CHANGES YOU WILL LOSE FOREVER!",
                  onConfirm: () =>
                      context.arepository.deleteRepository()).open(context),
              child: const Text("Delete")),
        ],
        if (state == RepoState.archived) ...[
          MenuButton(
              leading: const Icon(Icons.upload),
              onPressed: () => context.arepository.unarchive(context.github),
              child: const Text("Activate")),
          MenuButton(
              leading: const Icon(Icons.refresh_ionic),
              onPressed: () =>
                  context.arepository.updateArchive(context.github),
              child: const Text("Update Archive")),
          MenuButton(
              leading: const Icon(Icons.trash),
              onPressed: () => DialogConfirm(
                  title: "Delete Archive ${context.repository.fullName}?",
                  description:
                      "Are you sure you want to delete this archive? You will lose the image of this repository. THERE COULD BE LOCAL UNSTAGED OR UNPUSHED CHANGES IN THIS REPOSITORY ARCHIVE YOU COULD LOSE CHANGES FOREVER!",
                  destructive: true,
                  confirmText: "Delete Archive",
                  onConfirm: () =>
                      context.arepository.deleteRepository()).open(context),
              child: const Text("Delete Archive")),
        ],
        if (state == RepoState.cloud) ...[
          MenuButton(
              leading: const Icon(Icons.download),
              onPressed: () =>
                  context.arepository.ensureRepositoryActive(context.github),
              child: const Text("Clone")),
          MenuButton(
              leading: const Icon(Icons.archive),
              onPressed: () =>
                  context.arepository.archiveFromCloud(context.github),
              child: const Text("Archive")),
        ]
      ];

  @override
  bool get wantKeepAlive => true;
}
// File: lib/widget/active_section.dart
import 'package:alembic/util/extensions.dart';
import 'package:alembic/widget/repository_list.dart';
import 'package:arcane/arcane.dart';

class ActiveSection extends StatelessWidget {
  ActiveSection({super.key});

  @override
  Widget build(BuildContext context) => context.repositories.isEmpty
      ? const SliverToBoxAdapter()
      : BarSection(
          headerText: "Active",
          sliver: RepositoryListView(),
        );
}
// File: lib/widget/repository_list.dart
import 'package:alembic/util/extensions.dart';
import 'package:alembic/widget/repository_tile.dart';
import 'package:arcane/arcane.dart';
import 'package:github/github.dart';

class RepositoryListView extends StatelessWidget {
  RepositoryListView({super.key});

  @override
  Widget build(BuildContext context) => SliverList.builder(
        itemBuilder: (context, i) => Pylon<Repository>(
          value: context.repositories[i],
          builder: (context) => RepositoryTile(),
        ),
        itemCount: context.repositories.length,
      );
}
// File: lib/util/window.dart
import 'dart:io';

import 'package:alembic/main.dart';
import 'package:fast_log/fast_log.dart';
import 'package:flutter/material.dart';
import 'package:flutter_acrylic/flutter_acrylic.dart';
import 'package:screen_retriever/screen_retriever.dart';
import 'package:tray_manager/tray_manager.dart';
import 'package:window_manager/window_manager.dart';

class WindowUtil {
  static bool isDark = false;
  static bool iconIsDark = true;

  static Future<void> init() async {
    if (windowMode) {
      return;
    }

    verbose("  Starting Window Manager");
    await windowManager.ensureInitialized();
    verbose("  Starting System tray");
    await initSystemTray();
    verbose("  Starting Screen Retriever");
    Display d = await screenRetriever.getPrimaryDisplay();
    verbose("  Initializing Window");
    await Window.initialize();
    verbose("  Setup Blur Listeners");
    windowManager.addListener(HideOnBlurWindowListener());
    verbose("  Waiting for Window to be ready");
    windowManager.waitUntilReadyToShow(windowOptions, () async {
      verbose("Window is Ready. Hiding...");
      await windowManager.hide();
      verbose("Setting Window Properties (mv=false, bg=transparent)");
      await windowManager.setBackgroundColor(Colors.transparent);
      await windowManager.setMovable(false);
      verbose("Setting Window Position");
      await windowManager
          .setPosition(Offset(d.size.width - windowOptions.size!.width, 0));
      verbose("Setting Window Effect to menu 0x0000");
      await Window.setEffect(
        effect: WindowEffect.menu,
        color: const Color(0x00000000),
      );
    });
  }

  static Future<void> initSystemTray() async {
    if (windowMode) {
      return;
    }
    await trayManager.setIcon('assets/tray.png', isTemplate: true);
    Menu menu = Menu(
      items: [
        MenuItem(
          key: 'exit',
          label: 'Exit Alembic',
        ),
      ],
    );

    await trayManager.setContextMenu(menu);
    verbose("    Registering System Tray Event Handler");
    trayManager.addListener(AlembicTrayListener());
    verbose("    System Tray Ready");
  }

  static const WindowOptions windowOptions = WindowOptions(
    size: Size(400, 700),
    maximumSize: Size(400, 700),
    minimumSize: Size(400, 700),
    center: false,
    windowButtonVisibility: false,
    title: 'Alembic',
    alwaysOnTop: false,
    backgroundColor: Color(0x00000000),
    skipTaskbar: true,
    titleBarStyle: TitleBarStyle.hidden,
  );

  static Future<void> show() async {
    if (windowMode) {
      return;
    }
    Offset cursor = await screenRetriever.getCursorScreenPoint();
    Size windowSize = windowOptions.size!;
    await windowManager.setPosition(Offset(
        cursor.dx - windowSize.width / 2 > 0
            ? cursor.dx - windowSize.width / 2
            : 0,
        0));
    await windowManager.show();
  }

  static Future<void> hide() async {
    if (windowMode) {
      return;
    }
    await windowManager.hide();
  }
}

class AlembicTrayListener implements TrayListener {
  @override
  void onTrayIconMouseDown() {}

  @override
  void onTrayIconMouseUp() {
    WindowUtil.show();
  }

  @override
  void onTrayIconRightMouseDown() {}

  @override
  void onTrayIconRightMouseUp() {
    trayManager.popUpContextMenu();
  }

  @override
  void onTrayMenuItemClick(MenuItem menuItem) {
    if (menuItem.key == "exit") {
      windowManager.destroy().then((_) => exit(0));
    }
  }
}

class HideOnBlurWindowListener implements WindowListener {
  @override
  void onWindowBlur() {
    WindowUtil.hide();
  }

  @override
  void onWindowClose() {}

  @override
  void onWindowDocked() {}

  @override
  void onWindowEnterFullScreen() {}

  @override
  void onWindowEvent(String eventName) {}

  @override
  void onWindowFocus() {}

  @override
  void onWindowLeaveFullScreen() {}

  @override
  void onWindowMaximize() {}

  @override
  void onWindowMinimize() {}

  @override
  void onWindowMove() {}

  @override
  void onWindowMoved() {}

  @override
  void onWindowResize() {}

  @override
  void onWindowResized() {}

  @override
  void onWindowRestore() {}

  @override
  void onWindowUndocked() {}

  @override
  void onWindowUnmaximize() {}
}
// File: lib/util/semaphore.dart
import 'package:arcane/arcane.dart';

extension XFutureListSem on Iterable<Future Function()> {
  Future<List<T>> waitSemaphore<T>(
    int maxSimultaneous, {
    void Function(double)? progress,
  }) async {
    progress?.call(0.0);
    List<Future Function()> tx = toList();
    assert(maxSimultaneous > 0);
    int working = 0;
    List<Future<T>> t = [];
    for (int i = 0; i < length; i++) {
      while (working >= maxSimultaneous) {
        await Future.delayed(const Duration(milliseconds: 100));
      }

      if (working < maxSimultaneous) {
        working++;
        t.add(tx[i]().thenRun((result) => working--) as Future<T>);
      }

      progress?.call((i + 1) / length);
    }

    progress?.call(1.0);
    return await Future.wait(t);
  }
}
// File: lib/util/extensions.dart
import 'package:alembic/core/arcane_repository.dart';
import 'package:arcane/arcane.dart';
import 'package:github/github.dart';

extension XBuildContextRepo on BuildContext {
  BehaviorSubject<String?> get search => pylon<BehaviorSubject<String?>>();

  GitHub get github => pylon<GitHub>();

  Repository get repository => pylon<Repository>();

  ArcaneRepository get arepository => pylon<ArcaneRepository>();

  Organization get organization => pylon<Organization>();

  List<Repository> get repositories => pylon<List<Repository>>();

  Map<Organization, List<Repository>> get organizations =>
      pylon<Map<Organization, List<Repository>>>();
}

extension XSearchFilterRepo on List<Repository> {
  List<Repository> filterBy(String? query) => query == null || query.isEmpty
      ? this
      : where((i) => i.name.toLowerCase().contains(query.toLowerCase()))
          .toList();
}
// File: lib/util/goauth.dart
import 'package:github/github.dart';
import 'package:oauth2/oauth2.dart' as oauth2;
import 'package:url_launcher/url_launcher.dart';

class GitHubOAuth {
  static const String clientId = 'Iv23li7H08gj1niscAof';
  static const String clientSecret = 'bee79f9f1c7f186fd008311af2d12f730bd34490';
  static const String redirectUrl = 'http://localhost:8125/callback';
  static const String scope = 'repo,read:org';

  static Future<GitHub> createGitHubClient() async {
    final authorizationEndpoint =
        Uri.parse('https://github.com/login/oauth/authorize');
    final tokenEndpoint =
        Uri.parse('https://github.com/login/oauth/access_token');

    final grant = oauth2.AuthorizationCodeGrant(
      clientId,
      authorizationEndpoint,
      tokenEndpoint,
      secret: clientSecret,
    );

    final authorizationUrl =
        grant.getAuthorizationUrl(Uri.parse(redirectUrl), scopes: [scope]);

    // Open the authorization URL in a web browser
    await launchUrl(authorizationUrl);

    // Wait for the user to authorize and get the auth code
    // You'll need to implement a way to capture the redirect URL
    String authCode = await getAuthCodeFromRedirect();

    final client = await grant.handleAuthorizationCode(authCode);

    return GitHub(
        auth: Authentication.withToken(client.credentials.accessToken));
  }

  static Future<String> getAuthCodeFromRedirect() async {
    // Implement this method to capture the auth code from the redirect URL
    // This might involve using a local server or deep linking

    return "err";
  }
}
// File: lib/main.dart
import 'dart:convert';
import 'dart:io';
import 'dart:math';

import 'package:alembic/screen/splash.dart';
import 'package:alembic/util/window.dart';
import 'package:arcane/arcane.dart';
import 'package:fast_log/fast_log.dart';
import 'package:hive_flutter/adapters.dart';
import 'package:launch_at_startup/launch_at_startup.dart';
import 'package:package_info_plus/package_info_plus.dart';
import 'package:path_provider/path_provider.dart';

late Box box;
late Box boxSettings;
late PackageInfo packageInfo;
bool windowMode = false;
late String configPath;

void main() async {
  try {
    lDebugMode = true;
    setupArcaneDebug();
    WidgetsFlutterBinding.ensureInitialized();

    Directory appDocDir = await getApplicationDocumentsDirectory();
    configPath = "${appDocDir.path}/Alembic";
    await Directory(configPath).create(recursive: true);
    File logFile = File("$configPath/alembic.log");
    if (await logFile.exists()) {
      final fileSize = await logFile.length();
      if (fileSize > 1024 * 1024) {
        await logFile.delete();
        verbose("Log file deleted because it exceeded 1MB");
      }
    }
    IOSink logSink = logFile.openWrite(
      mode: FileMode.writeOnlyAppend,
    );
    lLogHandler = (cat, l) {
      logSink.writeln("${cat.name}: $l");
    };
    verbose("Getting package info");
    Future<PackageInfo> pinf = PackageInfo.fromPlatform();
    windowMode = Directory(
        "${appDocDir.path}/Alembic/WINDOW_MODE")
        .existsSync();
    info("${appDocDir.path}/Alembic");
    Hive.init("$configPath");
    verbose("Opening Hive boxes");
    Random r = Random(384858582220);
    box = await Hive.openBox("d",
        encryptionCipher:
        HiveAesCipher(List.generate(32, (_) => r.nextInt(256))));
    verbose("Opening settings box");
    boxSettings = await Hive.openBox("s");
    verbose("Init Window");
    await WindowUtil.init();
    verbose("Waiting for PackageInfo");
    await pinf.then((value) {
      packageInfo = value;
      verbose("PackageInfo: ${packageInfo.version}");
      verbose("Configuring launch startup mode");
      launchAtStartup.setup(
        appName: "Alembic",
        appPath: Platform.resolvedExecutable,
      );
    });

    verbose("Checking if autolaunch is enabled");
    if (boxSettings.get("autolaunch", defaultValue: true) == true) {
      launchAtStartup.enable();
      verbose("Autolaunch enabled");
    } else {
      launchAtStartup.disable();
      verbose("Autolaunch disabled");
    }
  } catch (e, es) {
    error("ERROR $e");
    error("ERROR $es");
  }

  success("=====================================");
  runApp(const Alembic());
}

class Alembic extends StatefulWidget {
  const Alembic({super.key});

  @override
  State<Alembic> createState() => _AlembicState();
}

class _AlembicState extends State<Alembic> {
  @override
  Widget build(BuildContext context) => ArcaneApp(
        debugShowCheckedModeBanner: false,
        title: 'Alembic',
        theme: ArcaneTheme(
            themeMode: ThemeMode.system,
            scheme: ContrastedColorScheme(
              dark: ColorSchemes.darkZinc(),
              light: ColorSchemes.lightZinc(),
            )),
        home: SplashScreen(),
      );
}

String expandPath(String path) {
  if (path.startsWith('~')) {
    final home = Platform.environment['HOME'] ?? '';
    return path.replaceFirst('~', home);
  }
  return path;
}

Future<int> cmd(String cmd, List<String> args,
    {BehaviorSubject<String>? stdout, String? workingDirectory}) async {
  cmd = expandPath(cmd);
  args = args.map(expandPath).toList();
  args = [
    "-ilc",
    [cmd, ...args].join(" "),
  ];
  cmd = Platform.environment['SHELL'] ?? '/bin/bash';

  verbose("cmd $cmd ${args.map((m) {
    if (m.contains("ghp_")) {
      return m.split(" ").map((i) {
        if (i.contains("ghp_")) {
          return "ghp_********";
        }
        return i;
      }).join(" ");
    }

    return m;
  }).join(" ")}");
  Process p =
      await Process.start(cmd, args, workingDirectory: workingDirectory);

  p.stdout.transform(utf8.decoder).transform(const LineSplitter()).map((i) {
    stdout?.add(i);
    return i;
  }).listen((line) => verbose("cmd $cmd stdout: $line"));

  p.stderr
      .transform(utf8.decoder)
      .transform(const LineSplitter())
      .listen((line) => error("cmd $cmd stderr: $line"));

  int c = await p.exitCode;

  if (c == 0) {
    success("cmd $cmd exit code: $c");
  } else {
    error("cmd $cmd exit code: $c");
  }

  return c;
}
// File: lib/screen/home.dart
import 'dart:async';
import 'dart:io';

import 'package:alembic/core/arcane_repository.dart';
import 'package:alembic/main.dart';
import 'package:alembic/screen/settings.dart';
import 'package:alembic/screen/splash.dart';
import 'package:alembic/util/extensions.dart';
import 'package:alembic/util/semaphore.dart';
import 'package:alembic/widget/active_section.dart';
import 'package:alembic/widget/organization_section.dart';
import 'package:alembic/widget/personal_section.dart';
import 'package:arcane/arcane.dart';
import 'package:fast_log/fast_log.dart';
import 'package:flutter/foundation.dart';
import 'package:github/github.dart';
import 'package:http/http.dart' as http;
import 'package:package_info_plus/package_info_plus.dart';
import 'package:path_provider/path_provider.dart';
import 'package:window_manager/window_manager.dart';

BehaviorSubject<int> update = BehaviorSubject.seeded(0);

class AlembicHome extends StatefulWidget {
  final GitHub github;

  const AlembicHome({super.key, required this.github});

  @override
  State<AlembicHome> createState() => _AlembicHomeState();
}

List<Repository> active = [];

class _AlembicHomeState extends State<AlembicHome> {
  late Future<List<Repository>> allRepos;
  Map<Organization, List<Repository>> orgRepos = {};
  List<Repository> personalRepos = [];
  final BehaviorSubject<int> _fetching = BehaviorSubject.seeded(0);
  BehaviorSubject<String?> search = BehaviorSubject.seeded(null);
  TextEditingController searchController = TextEditingController();
  BehaviorSubject<double?> progress = BehaviorSubject.seeded(null);

  Future<bool> checkForUpdates(BuildContext context,
      {bool force = false}) async {
    if (!force) {
      if (kDebugMode || kProfileMode) return false;
      if (!boxSettings.get("achup", defaultValue: true)) return false;
    }

    try {
      final response = await http.get(Uri.parse(
          'https://raw.githubusercontent.com/ArcaneArts/alembic/refs/heads/main/version'));
      if (response.statusCode == 200) {
        String liveVersion = response.body.trim(); // e.g. "1.0.2+3"
        PackageInfo inf = await PackageInfo.fromPlatform();
        String currentVersion = inf.version.trim(); // e.g. "1.0.2+3"

        if (liveVersion != currentVersion) {
          success(
              'A new version is available! Live version: $liveVersion, Current: $currentVersion');
          DialogConfirm(
            title: "Alembic $liveVersion Available",
            description:
                "A new version of Alembic is available. Would you like to download it?",
            confirmText: "Download",
            onConfirm: () async {
              TextToast("Downloading Alembic $liveVersion").open(context);
              String url =
                  "https://github.com/ArcaneArts/alembic/raw/refs/heads/main/dist/$liveVersion/alembic-$liveVersion+$liveVersion-macos.dmg";
              String path =
                  "${(await getTemporaryDirectory()).absolute.path}/Alembic/alembic-$liveVersion+$liveVersion-macos.dmg"
                      .replaceAll("//", "/");
              File(path).absolute.parent.createSync(recursive: true);
              verbose("Downloading $url to $path");
              http.Request request = http.Request('GET', Uri.parse(url));
              http.StreamedResponse streamedResponse =
                  await http.Client().send(request);
              IOSink file = File(path).openWrite();
              await streamedResponse.stream.pipe(file);
              await file.close();
              await cmd("open", [path]);
              warn("Shutting down alembic so the new version can be installed");
              windowManager.destroy().then((_) => exit(0));
            },
          ).open(context);
          return true;
        } else {
          info('The app is up to date (version: $currentVersion)');
        }
      } else {
        error(
            'Failed to fetch version file from GitHub. Status code: ${response.statusCode}');
      }
    } catch (e) {
      error('Error checking for updates: $e');
    }

    return false;
  }

  @override
  void initState() {
    active.clear();
    super.initState();
    allRepos = _fetchAllRepos().catchError((e, es) {
      error(e);
      error(es);
      return <Repository>[];
    }).then((r) {
      List<Future> work = [];
      for (Repository i in r) {
        ArcaneRepository r = ArcaneRepository(repository: i);

        if (active.any((i) => i.fullName == r.repository.fullName)) {
          continue;
        }

        work.add(r.isActive.then((g) {
          if (g) {
            active.add(i);
          }
        }));
      }

      return Future.wait(work).then((_) => r);
    }).thenRun((i) {
      updateActive();
    });

    Future.delayed(const Duration(milliseconds: 10000), () {
      for (Repository i in active) {
        verbose("Checking staleness of ${i.fullName}");
        ArcaneRepository r = ArcaneRepository(repository: i);
        r.isStaleActive.then((stale) {
          if (stale) {
            warn("${i.fullName} is stale, archiving");
            r.archive();
          }
        });
      }
    });
    checkForUpdates(context);
  }

  @override
  void dispose() {
    _fetching.close();
    search.close();
    super.dispose();
  }

  Future<List<Repository>> _fetchAllRepos() async => (await Future.wait([
        listRepositoriesAggressive().sip((i) => personalRepos.add(i)),
        ...(await widget.github.organizations
                .list()
                .where((i) => i.login != null)
                .sip((i) => orgRepos[i] = <Repository>[])
                .toList())
            .map((i) => listOrganizationRepositoriesAggressive(i.login!)
                .sip((j) => orgRepos[i]!.add(j)))
      ].map((i) => i.sip((j) => _fetching.add(_fetching.value + 1)).toList())))
          .expand((i) => i)
          .toList();

  Stream<Repository> listOrganizationRepositoriesAggressive(String org,
      {String type = 'all'}) {
    ArgumentError.checkNotNull(org);
    final params = <String, dynamic>{'type': type, "per_page": 100};

    return PaginationHelper(widget.github)
        .objects<Map<String, dynamic>, Repository>(
      'GET',
      '/orgs/$org/repos',
      Repository.fromJson,
      params: params,
    );
  }

  void updateActive() {
    allRepos.then((i) {
      active = i
          .where((i) => ArcaneRepository(repository: i).isActiveSync)
          .toSet()
          .toList();
    });
  }

  Stream<Repository> listRepositoriesAggressive(
      {String type = 'owner',
      String sort = 'full_name',
      String direction = 'asc'}) {
    final params = <String, dynamic>{
      'type': type,
      'sort': sort,
      'direction': direction,
      "per_page": 100,
    };

    return PaginationHelper(widget.github)
        .objects<Map<String, dynamic>, Repository>(
      'GET',
      '/user/repos',
      Repository.fromJson,
      params: params,
    );
  }

  @override
  Widget build(BuildContext context) => Pylon<GitHub>(
      value: widget.github,
      builder: (context) => SliverScreen(
          header: Bar(
            key: const ValueKey("header"),
            titleText: "Alembic",
            trailing: [
              SearchBox(
                leading: Icon(Icons.search_ionic),
                controller: searchController,
                placeholder: "Search Repositories",
                key: const ValueKey("search"),
                onChanged: (s) {
                  search.add(s.trim() == "" ? null : s.trim());
                },
              ),
              update.stream.map((i) => active).build((i) {
                updateActive();
                return progress.distinct().buildNullable((prog) => prog != null
                    ? CircularProgressIndicator(
                        size: 26,
                        animated: true,
                        value: prog,
                      )
                    : IconButtonMenu(icon: Icons.gear_six_fill, items: [
                        if (Directory(expandPath(config.workspaceDirectory))
                            .existsSync())
                          MenuButton(
                            leading: const Icon(Icons.folder),
                            onPressed: () => cmd('open', [
                              Directory(expandPath(config.workspaceDirectory))
                                  .absolute
                                  .path
                            ]),
                            child: const Text("Workspace Folder"),
                          ),
                        if (Directory(expandPath(config.archiveDirectory) +
                                "/archives".replaceAll("//", "/"))
                            .existsSync())
                          MenuButton(
                            leading: const Icon(Icons.folder),
                            onPressed: () => cmd('open', [
                              Directory(expandPath(config.archiveDirectory) +
                                      "/archives".replaceAll("//", "/"))
                                  .absolute
                                  .path
                            ]),
                            child: const Text("Archives Folder"),
                          ),
                        MenuButton(
                            child: Text("Bulk Actions"),
                            subMenu: [
                              if (active.isNotEmpty)
                                MenuButton(
                                  leading:
                                      const Icon(Icons.code_download_ionic),
                                  onPressed: () {
                                    progress.add(0);
                                    active
                                        .map((i) => () =>
                                            ArcaneRepository(repository: i)
                                                .ensureRepositoryUpdated(
                                                    context.github))
                                        .waitSemaphore(4, progress: (i) {
                                      setState(() {
                                        progress.add(i);
                                      });
                                    }).then((g) {
                                      progress.add(null);
                                    });
                                  },
                                  child: const Text("Pull Active"),
                                ),
                              if (active.isNotEmpty)
                                MenuButton(
                                  leading: const Icon(Icons.archive_box),
                                  onPressed: () {
                                    progress.add(0);
                                    active
                                        .map((i) => () =>
                                            ArcaneRepository(repository: i)
                                                .archive())
                                        .waitSemaphore(4, progress: (i) {
                                      setState(() {
                                        progress.add(i);
                                      });
                                    }).then((g) {
                                      progress.add(null);
                                    });
                                  },
                                  child: const Text("Archive Active"),
                                ),
                              MenuButton(
                                leading: const Icon(Icons.refresh_ionic),
                                onPressed: () {
                                  progress.add(0);
                                  allRepos.then((g) => g
                                          .where((i) =>
                                              ArcaneRepository(repository: i)
                                                  .isArchivedSync)
                                          .map((i) => () => ArcaneRepository(
                                                  repository: i)
                                              .updateArchive(context.github))
                                          .waitSemaphore(4, progress: (i) {
                                        setState(() {
                                          progress.add(i);
                                        });
                                      }).then((g) {
                                        progress.add(null);
                                      }));
                                },
                                child: const Text("Update Archives"),
                              ),
                              MenuButton(
                                leading: const Icon(Icons.upload),
                                onPressed: () {
                                  progress.add(0);
                                  allRepos.then((g) => g
                                          .where((i) =>
                                              ArcaneRepository(repository: i)
                                                  .isArchivedSync)
                                          .map((i) => () =>
                                              ArcaneRepository(repository: i)
                                                  .unarchive(context.github,
                                                      waitForPull: true))
                                          .waitSemaphore(4, progress: (i) {
                                        setState(() {
                                          progress.add(i);
                                        });
                                      }).then((g) {
                                        progress.add(null);
                                      }));
                                },
                                child: const Text("Activate Archives"),
                              ),
                              MenuButton(
                                leading: const Icon(Icons.refresh_ionic),
                                onPressed: () {
                                  progress.add(0);
                                  allRepos.then((g) => g
                                          .map((i) => () =>
                                              ArcaneRepository(repository: i)
                                                  .ensureRepositoryActive(
                                                      context.github))
                                          .waitSemaphore(4, progress: (i) {
                                        setState(() {
                                          progress.add(i);
                                        });
                                      }).then((g) {
                                        progress.add(null);
                                      }));
                                },
                                child: const Text("Activate Everything"),
                              ),
                            ],
                            leading: Icon(Icons.list)),
                        const MenuDivider(),
                        MenuButton(
                            leading: const Icon(Icons.log_out_outline_ionic),
                            child: const Text("Log Out"),
                            onPressed: () => DialogConfirm(
                                  title: "Log Out?",
                                  description:
                                      "Are you sure you want to log out? Your PAT will be deleted from this device.",
                                  destructive: true,
                                  onConfirm: () => box.deleteAll(
                                      ["1", "authenticated"]).then((_) {
                                    widget.github.dispose();
                                    Navigator.pushAndRemoveUntil(
                                        context,
                                        MaterialPageRoute(
                                            builder: (context) =>
                                                const SplashScreen()),
                                        (route) => false);
                                  }),
                                ).open(context)),
                        MenuButton(
                            leading: const Icon(Icons.refresh_ionic),
                            onPressed: () => Navigator.pushAndRemoveUntil(
                                context,
                                MaterialPageRoute(
                                    builder: (context) => const SplashScreen()),
                                (route) => false),
                            child: const Text("Restart")),
                        MenuButton(
                          leading: const Icon(Icons.gear_six),
                          onPressed: () => Arcane.push(context, Settings()),
                          child: const Text("Settings"),
                        ),
                        MenuDivider(),
                        MenuButton(
                          leading: const Icon(Icons.arrow_circle_up),
                          onPressed: () => checkForUpdates(context).then((g) {
                            if (!g) {
                              TextToast(
                                "Alembic is up to date!\n\nIf there really is an update, switch to a vpn or different network to propagate the cache faster.",
                                showDuration: 5.seconds,
                              ).open(context);
                            }
                          }),
                          child: const Text("Check for Updates"),
                        )
                      ]));
              })
            ],
          ),
          sliver: FutureBuilder<List<Repository>>(
            future: allRepos,
            builder: (context, snap) => !snap.hasData
                ? SliverFillRemaining(
                    child: Center(
                    child: Column(
                      mainAxisSize: MainAxisSize.min,
                      crossAxisAlignment: CrossAxisAlignment.center,
                      children: [
                        const CircularProgressIndicator(
                          size: 48,
                        ),
                        const Gap(32),
                        _fetching.build((i) => Text("Fetching $i Projects")),
                      ],
                    ),
                  ))
                : update.build(
                    (i) => PylonCluster(
                            pylons: [
                              Pylon<Map<Organization, List<Repository>>>.data(
                                  value: orgRepos),
                              Pylon<BehaviorSubject<String?>>.data(
                                  value: search)
                            ],
                            builder: (context) => MultiSliver(
                                  children: [
                                    context.search.buildNullable((query) =>
                                        Pylon<List<Repository>>(
                                            key: ValueKey(
                                                "active.${query ?? ""}"),
                                            value: active
                                                .filterBy(query)
                                                .sorted((b, a) =>
                                                    (getRepoConfig(a)
                                                                .lastOpen ??
                                                            0)
                                                        .compareTo(
                                                            getRepoConfig(b)
                                                                    .lastOpen ??
                                                                0)),
                                            builder: (context) =>
                                                ActiveSection())),
                                    context.search.buildNullable((query) =>
                                        Pylon<List<Repository>>(
                                            key: ValueKey(
                                                "personal.${query ?? ""}"),
                                            value:
                                                personalRepos.filterBy(query),
                                            builder: (context) =>
                                                PersonalSection())),
                                    ...orgRepos.keys
                                        .sorted((a, b) => (a.login ?? "org")
                                            .compareTo(b.login ?? "org"))
                                        .withPylons(
                                            (context) => OrganizationSection())
                                  ],
                                )),
                    loading: const SliverFillRemaining(
                        child: Center(
                      child: SizedBox(
                          height: 48,
                          width: 48,
                          child: CircularProgressIndicator()),
                    ))),
          )));
}

extension XStream<T> on Stream<T> {
  Stream<T> sip(Function(T) t) => map((i) {
        t(i);
        return i;
      });
}
// File: lib/screen/login.dart
import 'package:alembic/main.dart';
import 'package:alembic/screen/splash.dart';
import 'package:arcane/arcane.dart';
import 'package:flutter_svg/flutter_svg.dart';

class LoginScreen extends StatefulWidget {
  const LoginScreen({super.key});

  @override
  State<LoginScreen> createState() => _LoginScreenState();
}

class _LoginScreenState extends State<LoginScreen> {
  late TextEditingController tokenController;
  late FocusNode fToken;

  @override
  void initState() {
    tokenController = TextEditingController();
    fToken = FocusNode();
    super.initState();
  }

  void _doLogin(String? g) async {
    await box.put("1", g ?? tokenController.value.text);
    await box.put("authenticated", true);
    Navigator.pushAndRemoveUntil(
        context,
        MaterialPageRoute(builder: (context) => const SplashScreen()),
        (route) => false);
  }

  @override
  Widget build(BuildContext context) => FillScreen(
          child: Center(
        child: Column(
          mainAxisSize: MainAxisSize.min,
          crossAxisAlignment: CrossAxisAlignment.center,
          children: [
            SvgPicture.asset("assets/login.svg", width: 100, height: 100),
            PaddingHorizontal(
                padding: 32,
                child: TextField(
                  placeholder: "Github-Auth Token (Classic)",
                  focusNode: fToken,
                  controller: tokenController,
                  obscureText: true,
                  leading: Icon(Icons.lock_fill),
                  onSubmitted: (g) {
                    _doLogin(g);
                  },
                  textAlign: TextAlign.left,
                ))
          ],
        ),
      ));
}
// File: lib/screen/splash.dart
import 'package:alembic/main.dart';
import 'package:alembic/screen/home.dart';
import 'package:alembic/screen/login.dart';
import 'package:arcane/arcane.dart';
import 'package:flutter_svg/flutter_svg.dart';
import 'package:github/github.dart';

class SplashScreen extends StatefulWidget {
  const SplashScreen({super.key});

  @override
  State<SplashScreen> createState() => SplashScreenState();
}

class SplashScreenState extends State<SplashScreen> {
  void doLogin() {
    WidgetsBinding.instance.addPostFrameCallback((_) {
      Navigator.pushAndRemoveUntil(
          context,
          MaterialPageRoute(builder: (context) => const LoginScreen()),
          (route) => false);
    });
  }

  @override
  void initState() {
    if (!box.get("authenticated", defaultValue: false)) {
      doLogin();
    } else {
      WidgetsBinding.instance.addPostFrameCallback((_) {
        Navigator.pushAndRemoveUntil(
            context,
            MaterialPageRoute(
                builder: (context) => AlembicHome(github: auth())),
            (route) => false);
      });
    }

    super.initState();
  }

  GitHub auth() => GitHub(auth: Authentication.withToken(box.get("1")));

  @override
  Widget build(BuildContext context) {
    return FillScreen(
      child: Center(
        child: SvgPicture.asset("assets/icon.svg", width: 150, height: 150),
      ),
    );
  }
}
// File: lib/screen/repository_settings.dart
import 'package:alembic/screen/settings.dart';
import 'package:alembic/util/extensions.dart';
import 'package:arcane/arcane.dart';

class RepositorySettings extends StatelessWidget {
  const RepositorySettings({super.key});

  @override
  Widget build(BuildContext context) => SettingsScreen(
          options: OptionScreen(
              name: "Settings",
              description: context.repository.fullName,
              options: [
            OptionGroup(name: "Tools", options: [
              StringOption(
                name: "Workspace Directory",
                reader: () => getRepoConfig(context.repository).openDirectory,
                writer: (v) => setRepoConfig(context.repository,
                    getRepoConfig(context.repository)..openDirectory = v ?? ""),
                icon: Icons.folder_fill,
                description:
                    "The subdirectory to open the project in with tools",
              ),
              EnumOption<ApplicationTool>(
                  name: "Editor Tool",
                  options: ApplicationTool.values,
                  reader: () => getRepoConfig(context.repository).editorTool,
                  writer: (v) => setRepoConfig(
                      context.repository,
                      getRepoConfig(context.repository)
                        ..editorTool = v ?? ApplicationTool.intellij),
                  icon: Icons.app_window,
                  description:
                      "Overrides The default IDE to use for opening projects",
                  defaultValue: ApplicationTool.intellij,
                  decorator: (v) => Basic(
                        title: Text(v.displayName).withTooltip(v.help ?? ""),
                      )),
              EnumOption<GitTool>(
                  name: "Git Tool",
                  options: GitTool.values,
                  reader: () => getRepoConfig(context.repository).gitTool,
                  writer: (v) => setRepoConfig(
                      context.repository,
                      getRepoConfig(context.repository)
                        ..gitTool = v ?? GitTool.gitkraken),
                  icon: Icons.git_branch,
                  description:
                      "Overrides The default tool to use for opening repositories",
                  defaultValue: GitTool.gitkraken,
                  decorator: (v) => Basic(
                        title: Text(v.displayName),
                      )),
            ])
          ]));
}
// File: lib/screen/settings.dart
import 'dart:convert';

import 'package:alembic/main.dart';
import 'package:arcane/arcane.dart';
import 'package:file_picker/file_picker.dart';
import 'package:github/github.dart';
import 'package:launch_at_startup/launch_at_startup.dart';

enum ApplicationTool { vscode, intellij, zed, xcode }

extension XApplicationTool on ApplicationTool {
  String get displayName => switch (this) {
        ApplicationTool.vscode => "VS Code",
        ApplicationTool.intellij => "IntelliJ",
        ApplicationTool.zed => "Zed",
        ApplicationTool.xcode => "Xcode",
      };

  String? get help => switch (this) {
        ApplicationTool.intellij => "Install via JetBrains Toolbox",
        ApplicationTool.vscode =>
          "To use, open Command Palette > Install 'code' command",
        ApplicationTool.zed => "To use, open Command Palette > cli:install",
        ApplicationTool.xcode => "Works out of the box",
      };

  Future<void> launch(String path) => switch (this) {
        ApplicationTool.vscode => cmd("code", [path]),
        ApplicationTool.intellij => cmd("idea", [path]),
        ApplicationTool.zed => cmd("zed", [path]),
        ApplicationTool.xcode => cmd("xed", [path]),
      };
}

enum GitTool { githubDesktop, gitkraken, tower, fork, sourcetree }

extension XGitTool on GitTool {
  String get displayName => switch (this) {
        GitTool.githubDesktop => "GH Desktop",
        GitTool.gitkraken => "GitKraken",
        GitTool.tower => "Tower",
        GitTool.fork => "Fork",
        GitTool.sourcetree => "SourceTree",
      };

  Future<void> launch(String path) => switch (this) {
        GitTool.gitkraken => cmd("gitkraken", ["-p", path]),
        _ => Future.value()
      };
}

String? compressPath(String? path) {
  if (path == null) return null;
  if (path.startsWith("/Volumes/Macintosh HD/Users/")) {
    List<String> p = path.substring(1).split("/");
    print(p);
    return "~/${p.sublist(4).join("/")}";
  }
  return path;
}

AlembicRepoConfig getRepoConfig(Repository repo) =>
    AlembicRepoConfig.fromJson(boxSettings.get("config/${repo.fullName}",
        defaultValue: AlembicRepoConfig().json));

void setRepoConfig(Repository repo, AlembicRepoConfig c) =>
    boxSettings.put("config/${repo.fullName}", c.json);

AlembicConfig get config => AlembicConfig.fromJson(
    boxSettings.get("config", defaultValue: AlembicConfig().json));
void setConfig(AlembicConfig c) => boxSettings.put("config", c.json);

class Settings extends StatefulWidget {
  const Settings({super.key});

  @override
  State<Settings> createState() => _SettingsState();
}

class _SettingsState extends State<Settings> {
  @override
  Widget build(BuildContext context) => SliverScreen(
        header: Bar(
          titleText: "Settings",
        ),
        sliver: MultiSliver(
          children: [
            BarSection(
                subtitleText: "Application",
                sliver: SListView(
                  children: [
                    CheckboxTile(
                      title: Text("Launch at Startup"),
                      leading: Icon(Icons.open_ionic),
                      subtitle: Text("Add / Remove Alembic from Login Items"),
                      value: boxSettings.get("autolaunch", defaultValue: true),
                      onChanged: (b) {
                        boxSettings.put("autolaunch", b);

                        if (b == true) {
                          launchAtStartup.enable();
                        } else {
                          launchAtStartup.disable();
                        }

                        setState(() {});
                      },
                    ),
                    CheckboxTile(
                      title: Text("Check for Updates on Launch"),
                      leading: Icon(Icons.arrow_circle_up),
                      subtitle: Text(
                          "Allow Alembic to check for updates when launched"),
                      value: boxSettings.get("achup", defaultValue: true),
                      onChanged: (b) {
                        boxSettings.put("achup", b);
                        setState(() {});
                      },
                    )
                  ],
                )),
            BarSection(
                subtitleText: "Tools",
                sliver: SListView(
                  children: [
                    ListTile(
                      title: Text("Workspace Directory"),
                      subtitle: Text(config.workspaceDirectory),
                      leading: Icon(Icons.folder_fill),
                      onPressed: () => FilePicker.platform
                          .getDirectoryPath(
                            initialDirectory:
                                expandPath(config.workspaceDirectory),
                            dialogTitle: "Select Workspace Directory",
                          )
                          .then((v) => compressPath(v))
                          .then((v) {
                        if (v == null) {
                          return;
                        }

                        setConfig(config..workspaceDirectory = v);
                        setState(() {});
                      }),
                    ),
                    ListTile(
                      title: Text("Archive Directory"),
                      subtitle: Text(config.archiveDirectory),
                      leading: Icon(Icons.archive_fill),
                      onPressed: () => FilePicker.platform
                          .getDirectoryPath(
                            initialDirectory:
                                expandPath(config.archiveDirectory),
                            dialogTitle: "Select Archive Directory",
                          )
                          .then((v) => compressPath(v))
                          .then((v) {
                        if (v == null) {
                          return;
                        }

                        setConfig(config..archiveDirectory = v);
                        setState(() {});
                      }),
                    ),
                    ListTile(
                      leading: Icon(Icons.app_window),
                      title: Text("Editor Tool"),
                      subtitle: Column(
                        mainAxisSize: MainAxisSize.min,
                        crossAxisAlignment: CrossAxisAlignment.start,
                        children: [
                          Gap(8),
                          CardCarousel(
                            children: [
                              RadioCards<ApplicationTool>(
                                items: ApplicationTool.values,
                                value: config.editorTool ??
                                    ApplicationTool.intellij,
                                builder: (v) => Basic(
                                  title: Text(v.displayName)
                                      .withTooltip(v.help ?? ""),
                                ),
                                onChanged: (v) {
                                  setConfig(config..editorTool = v);
                                  setState(() {});
                                },
                              )
                            ],
                          ),
                          Gap(8),
                          Text("The IDE to use for opening projects")
                        ],
                      ),
                    ),
                    ListTile(
                      leading: Icon(Icons.git_branch),
                      title: Text("Git Tool"),
                      subtitle: Column(
                        mainAxisSize: MainAxisSize.min,
                        crossAxisAlignment: CrossAxisAlignment.start,
                        children: [
                          Gap(8),
                          CardCarousel(
                            children: [
                              RadioCards<GitTool>(
                                items: GitTool.values,
                                value: config.gitTool ?? GitTool.gitkraken,
                                builder: (v) => Basic(
                                  title: Text(v.displayName),
                                ),
                                onChanged: (v) {
                                  setConfig(config..gitTool = v);
                                  setState(() {});
                                },
                              )
                            ],
                          ),
                          Gap(8),
                          Text("he tool to use for opening repositories")
                        ],
                      ),
                    )
                  ],
                )),
            BarSection(
                subtitleText: "About",
                sliver: SListView(
                  children: [
                    ListTile(
                      leading: Icon(Icons.folder_fill),
                      title: Text("Config Path"),
                      subtitle: Text(configPath),
                      onPressed: () => cmd("open", [configPath]),
                    ),
                    ListTile(
                      leading: Icon(Icons.list),
                      title: Text("View Logs"),
                      subtitle: Text(configPath),
                      onPressed: () => cmd("open", ["$configPath/alembic.log"]),
                    )
                  ],
                ))
          ],
        ),
      );
}

class AlembicConfig {
  late ApplicationTool editorTool;
  late GitTool gitTool;
  late String workspaceDirectory;
  late String archiveDirectory;
  late int daysToArchive;

  AlembicConfig(
      {this.editorTool = ApplicationTool.intellij,
      this.gitTool = GitTool.gitkraken,
      this.workspaceDirectory = "~/development/workspace",
      this.archiveDirectory = "~/Documents/Alembic",
      this.daysToArchive = 30});

  AlembicConfig.fromJson(String json) {
    final data = jsonDecode(json);
    editorTool =
        ApplicationTool.values.select((e) => e.name == data["editorTool"]) ??
            AlembicConfig().editorTool;
    gitTool = GitTool.values.select((e) => e.name == data["gitTool"]) ??
        AlembicConfig().gitTool;
    workspaceDirectory =
        data["workspaceDirectory"] ?? AlembicConfig().workspaceDirectory;
    archiveDirectory =
        data["archiveDirectory"] ?? AlembicConfig().archiveDirectory;
    daysToArchive = data["daysToArchive"] ?? AlembicConfig().daysToArchive;
  }

  String get json => jsonEncode({
        "editorTool": editorTool.name,
        "gitTool": gitTool.name,
        "workspaceDirectory": workspaceDirectory,
        "archiveDirectory": archiveDirectory,
        "daysToArchive": daysToArchive
      });
}

class AlembicRepoConfig {
  late ApplicationTool? editorTool;
  late GitTool? gitTool;
  late String openDirectory;
  late int? lastOpen;

  AlembicRepoConfig(
      {this.editorTool, this.gitTool, this.openDirectory = "/", this.lastOpen});

  AlembicRepoConfig.fromJson(String json) {
    final data = jsonDecode(json);
    editorTool =
        ApplicationTool.values.select((e) => e.name == data["editorTool"]) ??
            config.editorTool;
    gitTool = GitTool.values.select((e) => e.name == data["gitTool"]) ??
        config.gitTool;
    openDirectory = data["openDirectory"] ?? AlembicRepoConfig().openDirectory;
    lastOpen = data["lastOpen"];
  }

  String get json => jsonEncode({
        if (editorTool != null && editorTool != config.editorTool)
          "editorTool": editorTool!.name,
        if (gitTool != null && gitTool != config.gitTool)
          "gitTool": gitTool!.name,
        "openDirectory": openDirectory,
        if (lastOpen != null) "lastOpen": lastOpen
      });
}
